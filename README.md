텍스트 알피지 클래스 & 파일분할 버전

목적
클래스 역할에 따라 목적을 나눠 파일을 분리함.
예) object 클래스는 object관리만 한다.


생각한점
오브젝트의 정보를 출력하는 Render를 MainGame클래스에 둘 것 인가, Object클래스에 둘 것인가?

책임의 분리를 기본개념으로 이유를 정리

1. 정보를 알고 있는 주체가 책임을 져야한다(정보은닉/캡슐화)
   - 오브젝트가 자신의 상태를 가장 잘 알고있다.
   - MainGame에서 출력코드를 작성하면 오브젝트 클래스에 의존적이게되고 캡슐화가 깨진다
2. 다형성과의 자연스러운 결합


# CObject 클래스의 출력 책임 설계 결정

## 개요

본 문서는 `CObject` 클래스에 `print()` 함수를 설계한 이유를 설명합니다.  
이는 객체지향 프로그래밍(OOP)의 핵심 원칙 중 하나인 **책임의 분리(Separation of Responsibility)**를 따르며,  
유지보수성과 확장성을 고려한 결정입니다.

---

## 결론

> ✅ `print()` 함수는 `MainGame` 클래스가 아닌, `CObject` 클래스에 정의하는 것이 더 바람직합니다.

---

## 이유

### 🎯 1. 정보를 가장 잘 아는 객체가 출력 책임을 가져야 한다 (캡슐화 원칙)

- `CObject`는 자신의 상태(이름, HP, 위치 등)를 알고 있으며,
- 출력 형식이 바뀌더라도 **객체 내부만 수정하면 됨**
- 반면, `MainGame`이 출력하면 **CObject 내부 정보에 의존**하게 되어 **캡슐화가 깨짐**

#### ❌ 잘못된 설계 예:
```cpp
void MainGame::PrintObject(CObject* obj) {
    std::cout << obj->hp << ", " << obj->name << ", " << obj->position; // 내부 접근
}
